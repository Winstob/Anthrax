/* ---------------------------------------------------------------- *\
 * model_rotation.comp
 * Author: Gavin Ralston
 * Date Created: 2025-03-01
 * 
 * Even though the main rendering code uses uints to model the
 * octree and the corner of the octree is 0, we need to use ints
 * and have 0 represent the center here to avoid overflow
 * (underflow?).
\* ---------------------------------------------------------------- */
#version 460

#define WORKGROUP_SIZE 2

#define PI 3.14

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = WORKGROUP_SIZE) in;

struct OctreeNode
{
	uint indirection;
	uint voxel_type;
};

layout (std430, binding = 0) buffer octree_ssbo
{
	OctreeNode octree[];
};

layout (std430, binding = 1) buffer freelist_ssbo
{
	uint freelist[];
};

layout (std140, binding = 2) readonly uniform octree_layer_ubo
{
	uint octree_layer;
};

uint getPoolIndex(in uint layer, in uvec3 pos);
uint readIndirectionPool(in uint base_location, in uint node_index);
uint readUniformityPool(in uint base_location, in uint node_index);
uint readVoxelTypePool(in uint base_location, in uint node_index);
void rotateVoxelSingleAxis(inout ivec3 pos, float angle, int axis, int mode);
void insertFreelistVal(in uint index, in bool val);

uint octree_width = 1u << octree_layer;
int half_octree_width = int(octree_width >> 1);

// There will be problems with octree_width values approaching UINT_MAX, but i really
// dont think models that large will be rotated anyway.
// If my math is correct the largest octree width that could posibly work is 2^28, but
// even then im pretty sure the octree pool would be too large to be represented with
// 32-bit unsigned ints.
void main()
{
	// calculate pos from instance index
	uvec3 pos = uvec3(gl_GlobalInvocationID);

	// calculate the pool index in the input octree
	uint pool_index = getPoolIndex(octree_layer, pos);	

	// loop through all children
	uint child_pool_index_base = getPoolIndex(octree_layer+1, pos*2);
	uint voxel_type = octree[child_pool_index_base].voxel_type;
	bool can_merge = true;
	for (uint child = 0; child < 8; child++)
	{
		if (voxel_type != octree[child_pool_index_base+child].voxel_type)
			can_merge = false;
	}
	if (can_merge)
	{
		octree[pool_index].voxel_type = voxel_type;
		octree[pool_index].indirection = 0;
		for (uint child = 0; child < 8; child++)
		{
			insertFreelistVal(child_pool_index_base+child, true);
		}
	}
	else
	{
		octree[pool_index].voxel_type = voxel_type;
		octree[pool_index].indirection = child_pool_index_base;
	}
	insertFreelistVal(pool_index, false);
	
	return;
}


uint getPoolIndex(in uint layer, in uvec3 pos)
{
	uint base_offset = ((1 << (3*(layer-1))) - 1) / 7 * 8;
	uint index = 0u;
	for (int i = 0; i < 10; i++)
	{
		index = bitfieldInsert(index, bitfieldExtract(pos.x, i, 1), i*3, 1);
		index = bitfieldInsert(index, bitfieldExtract(pos.y, i, 1), i*3+1, 1);
		index = bitfieldInsert(index, bitfieldExtract(pos.z, i, 1), i*3+2, 1);
	}
	return base_offset + index;
}


void insertFreelistVal(in uint index, in bool val)
{
	uint bit = (val) ? 1u : 0u;
	uint list_index = index >> 5;
	int bit_offset = 31 - int(index % 32);
	freelist[list_index] = bitfieldInsert(freelist[list_index], bit, bit_offset, 1);
	return;
}
