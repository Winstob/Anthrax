/* ---------------------------------------------------------------- *\
 * main.comp
 * Author: Gavin Ralston
 * Date Created: 2024-08-06
\* ---------------------------------------------------------------- */
#version 460

#define WORKGROUP_SIZE 8

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct uinfl
{
  uint int_component;
  float dec_component;
};
uinfl uinflAdd(uinfl first, uinfl second);
uinfl uinflSub(uinfl first, uinfl second);

struct ufvec3
{
  uvec3 int_component;
  vec3 dec_component;
};
ufvec3 uf3Add(in ufvec3 first, in ufvec3 second);

struct WorldLocation
{
	/*
  ivec3 int_component;
  vec3 dec_component;
	*/
	ufvec3 loc;
	uint level;
};

struct DirectedLight
{
  vec3 direction;
  vec3 scatter_color;
  vec3 color;
};

struct Material
{
  vec3 diffuse;
  vec3 specular;
  float shininess;
  float opacity;
  float refraction_index;
};

layout (std430, binding = 0) readonly buffer indirection_pool_ssbo
{
	int indirection_pool[];
};

layout (std430, binding = 1) readonly buffer uniformity_pool_ssbo
{
	uint uniformity_pool[];
};

layout (std430, binding = 2) readonly buffer voxel_type_pool_ssbo
{
	uint voxel_type_pool[];
};

layout (std140, binding = 3) uniform num_levels_ubo
{
	int num_levels;
};

layout (std140, binding = 4) uniform focal_distance_ubo
{
	float focal_distance;
};

layout (std140, binding = 5) uniform screen_width_ubo
{
	int screen_width;
};

layout (std140, binding = 6) uniform screen_height_ubo
{
	int screen_height;
};

layout (std140, binding = 7) uniform camera_position_ubo
{
	//WorldLocation camera_position;
	ufvec3 camera_position;
};

layout (std140, binding = 8) uniform camera_right_ubo
{
	vec3 camera_right;
};

layout (std140, binding = 9) uniform camera_up_ubo
{
	vec3 camera_up;
};

layout (std140, binding = 10) uniform camera_forward_ubo
{
	vec3 camera_forward;
};

layout (std140, binding = 11) uniform sunlight_ubo
{
	DirectedLight sunlight_TMP;
};

layout (rgba32f, binding = 12) uniform image2D out_image;


struct Ray
{
	vec3 direction;
	ufvec3 world_location;
};


vec2 screen_position = vec2(gl_GlobalInvocationID.x, -gl_GlobalInvocationID.y+screen_height)/vec2(screen_width, screen_height)*2.0-1.0;

// forward function declarations
vec3 calculateMainRayDirection();
uint getVoxelType(ufvec3 world_position);
bool rayMarch(inout Ray ray);

uint readIndirectionPool(in uint base_location, in uint node_index);
uint readUniformityPool(in uint base_location, in uint node_index);
uint readVoxelTypePool(in uint base_location, in uint node_index);

void main()
{
	/*
	//out_image[0] = 0.0;
	//imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(vec2(gl_GlobalInvocationID.xy/500.0), 0.0, 1.0));
	//imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(vec2(gl_GlobalInvocationID.xy/focal_distance), 0.0, 1.0));
	imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(screen_position, 0.0, 1.0));
	int i = int(mod(gl_GlobalInvocationID.x, 512));
	i = int(gl_GlobalInvocationID.x);
	float val = float(indirection_pool[i]);
	//float val = float(indirection_pool[400]);
	imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(val, 0.0, 0.0, 1.0));
	*/

	Ray ray;
	ray.direction = calculateMainRayDirection();
	ray.world_location = camera_position;
	uint voxel_type = 0;
	for (uint i = 0; i < 100; i++)
	{
		if (!rayMarch(ray))
		{
			voxel_type = getVoxelType(ray.world_location);
			break;
		}
	}
	if (voxel_type == 0)
	{
		imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(0.0, 0.0, 0.0, 1.0));
	}
	else
	{
		//imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 1.0, 1.0, 1.0));
		imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(ray.world_location.dec_component, 1.0));
	}
	//imageStore(out_image, ivec2(gl_GlobalInvocationID.xy), vec4(ray.direction, 1.0));
	return;
}


vec3 calculateMainRayDirection()
{
  vec3 x = camera_right * screen_position.x;
  vec3 y = camera_up * screen_position.y * float(screen_height) / float(screen_width);
  vec3 z = camera_forward * focal_distance;
  return normalize(x + y + z);
}


uint getVoxelType(ufvec3 world_position)
{
	uint indirection_pointer = 0;
	uint current_node_index = 0;
	uint level = num_levels - 1;
	// starting at the top level, descend until a uniform level is reached
	for (; level >= 0;)
	{
		current_node_index = 0;
		current_node_index |= ((world_position.int_component.x >> (3*level)) & 7);
		current_node_index |= ((world_position.int_component.y >> (3*level)) & 7) << 3; 
		current_node_index |= ((world_position.int_component.z >> (3*level)) & 7) << 6;
		if (level == 0) break;

		if (readUniformityPool(indirection_pointer, current_node_index) == 1)
		{
			break;
		}

		uint next_indirection_pointer = readIndirectionPool(indirection_pointer, current_node_index);
		if (next_indirection_pointer == 0)
		{
			break;
		}
		indirection_pointer = next_indirection_pointer;
		level--;
	}
	return readVoxelTypePool(indirection_pointer, current_node_index);
}


bool rayMarch(inout Ray ray)
{
	uint indirection_pointer = 0;
	uint current_node_index = 0;
	uint level = num_levels - 1;
	// starting at the top level, descend until a uniform level is reached
	while (true)
	{
		current_node_index = 0;
		current_node_index |= ((ray.world_location.int_component.x >> (3*level)) & 7u);
		current_node_index |= ((ray.world_location.int_component.y >> (3*level)) & 7u) << 3; 
		current_node_index |= ((ray.world_location.int_component.z >> (3*level)) & 7u) << 6;
		if (level == 0) break;

		if (readUniformityPool(indirection_pointer, current_node_index) == 1)
		{
			break;
		}

		uint new_indirection_pointer = readIndirectionPool(indirection_pointer, current_node_index);
		if (new_indirection_pointer == 0)
		{
			break;
		}
		indirection_pointer = new_indirection_pointer;
		level--;
	}
	uint voxel_type = readVoxelTypePool(indirection_pointer, current_node_index);
	if (voxel_type != 0)
	{
		return false;
	}

	// find location of the corner in the general direction of the ray
	ufvec3 edge_location = ray.world_location;
	ufvec3 outside_edge_location;
	ufvec3 difference;
	uint max_value_within_level_single_axis = (0xFFFFFFFFu >> (32-(3*level)));
	if (level == 0) max_value_within_level_single_axis = 0u; // 1 >> 1 = 1: special case
	bvec3 axis_leaves_boundary = bvec3(false);
	for (uint i = 0; i < 3; i++)
	{
		if (ray.direction[i] >= 0.0)
		{
			edge_location.int_component[i] |= max_value_within_level_single_axis;
			edge_location.dec_component[i] = 1.0;
			outside_edge_location.int_component[i] = edge_location.int_component[i] + 1;
			outside_edge_location.dec_component[i] = 0.0;
			difference.int_component[i] = edge_location.int_component[i] - ray.world_location.int_component[i];
			difference.dec_component[i] = edge_location.dec_component[i] - ray.world_location.dec_component[i];
			if (edge_location.int_component[i] == (0xFFFFFFFFu >> (32-(3*num_levels))))
				axis_leaves_boundary[i] = true;
		}
		else
		{
			edge_location.int_component[i] &= ~(max_value_within_level_single_axis);
			edge_location.dec_component[i] = 0.0;
			outside_edge_location.int_component[i] = edge_location.int_component[i] - 1;
			outside_edge_location.dec_component[i] = 1.0;
			difference.int_component[i] = ray.world_location.int_component[i] - edge_location.int_component[i]; 
			difference.dec_component[i] = ray.world_location.dec_component[i] - edge_location.dec_component[i];
			if (edge_location.int_component[i] == 0u)
				axis_leaves_boundary[i] = true;
		}
	}
	// correct for difference = 0 (divide by 0) case
	// TODO: make this better
	for (uint i = 0; i < 3; i++)
	{
		if (difference.int_component[i] == 0 && difference.dec_component[i] == 0.0)
			difference.dec_component[i] = 0.001;
	}

	// find dominant axis
	/*
	float tmp = float(difference.int_component) / ray.direction;
	ufvec3 tmp_ivec3;
	tmp_ivec3.int_component = uvec3(tmp);
	tmp_ivec3.dec_component = tmp - vec3(tmp_vec3.int_component);
	ufvec3 tmp_vec3;
	tmp_vec3.int_component = uvec3(0);
	tmp_vec3.dec_component = difference.dec_component / ray.direction;
	ufvec3 travel_multipliers = uf3Add(tmp_ivec3, tmp_vec3);
	*/
	// TODO: use ufvec3 for travel_multipliers - this method is extremely lossy at higher values
	vec3 travel_multipliers = (vec3(difference.int_component) + difference.dec_component) / abs(ray.direction);
	//travel_multipliers *= sign(travel_multipliers);

	bool out_of_bounds = false;

	if (travel_multipliers.x < travel_multipliers.y && travel_multipliers.x < travel_multipliers.z)
	{
		// x is the dominant axis
		if (!axis_leaves_boundary.x)
		{
			ray.world_location.int_component.x = outside_edge_location.int_component.x;
			ray.world_location.dec_component.x = outside_edge_location.dec_component.x;
		}
		else
		{
			ray.world_location.int_component.x = edge_location.int_component.x;
			ray.world_location.dec_component.x = edge_location.dec_component.x;
			out_of_bounds = true;
		}

    vec2 tmp = vec2(ray.world_location.int_component.yz) + ray.world_location.dec_component.yz;
    tmp += ray.direction.yz * travel_multipliers.x;
    ray.world_location.int_component.yz = uvec2(tmp);
    ray.world_location.dec_component.yz = tmp - vec2(ray.world_location.int_component.yz);
	}
	else if (travel_multipliers.y < travel_multipliers.z)
	{
		// y is the dominant axis
		if (!axis_leaves_boundary.y)
		{
			ray.world_location.int_component.y = outside_edge_location.int_component.y;
			ray.world_location.dec_component.y = outside_edge_location.dec_component.y;
		}
		else
		{
			ray.world_location.int_component.y = edge_location.int_component.y;
			ray.world_location.dec_component.y = edge_location.dec_component.y;
			out_of_bounds = true;
		}

    vec2 tmp = vec2(ray.world_location.int_component.xz) + ray.world_location.dec_component.xz;
    tmp += ray.direction.xz * travel_multipliers.y;
    ray.world_location.int_component.xz = uvec2(tmp);
    ray.world_location.dec_component.xz = tmp - vec2(ray.world_location.int_component.xz);
	}
	else
	{
		// z is the dominant axis
		if (!axis_leaves_boundary.z)
		{
			ray.world_location.int_component.z = outside_edge_location.int_component.z;
			ray.world_location.dec_component.z = outside_edge_location.dec_component.z;
		}
		else
		{
			ray.world_location.int_component.z = edge_location.int_component.z;
			ray.world_location.dec_component.z = edge_location.dec_component.z;
			out_of_bounds = true;
		}

    vec2 tmp = vec2(ray.world_location.int_component.xy) + ray.world_location.dec_component.xy;
    tmp += ray.direction.xy * travel_multipliers.z;
    ray.world_location.int_component.xy = uvec2(tmp);
    ray.world_location.dec_component.xy = tmp - vec2(ray.world_location.int_component.xy);
	}
	if (out_of_bounds) return false;
	return true;
}


ufvec3 uf3Add(in ufvec3 first, in ufvec3 second)
{
	ufvec3 result;
	result.int_component = first.int_component + second.int_component;
	result.dec_component = first.dec_component + second.dec_component;
	if (result.dec_component.x >= 1.0)
	{
		result.dec_component.x -= 1.0;
		result.int_component.x += 1;
	}
	if (result.dec_component.x < 0.0)
	{
		result.dec_component.x += 1.0;
		result.int_component.x -= 1;
	}
	if (result.dec_component.y >= 1.0)
	{
		result.dec_component.y -= 1.0;
		result.int_component.y += 1;
	}
	if (result.dec_component.y < 0.0)
	{
		result.dec_component.y += 1.0;
		result.int_component.y -= 1;
	}
	if (result.dec_component.z >= 1.0)
	{
		result.dec_component.z -= 1.0;
		result.int_component.z += 1;
	}
	if (result.dec_component.z < 0.0)
	{
		result.dec_component.z += 1.0;
		result.int_component.z -= 1;
	}

	return result;
}


uint readIndirectionPool(in uint base_location, in uint node_index)
{
	return indirection_pool[(base_location << 9) | node_index];
}


uint readUniformityPool(in uint base_location, in uint node_index)
{
	uint index_preunpack = (base_location << 9) | node_index;
	uint true_index = index_preunpack >> 5;
	uint bit_location = index_preunpack & 0x1F;
	return ((uniformity_pool[true_index] >> bit_location) & 1);
}


uint readVoxelTypePool(in uint base_location, in uint node_index)
{
	return voxel_type_pool[(base_location << 9) | node_index];
}
